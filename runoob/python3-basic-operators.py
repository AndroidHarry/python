
'''
得知 python 中数字有以下的表示方式：

2 进制是以 0b 开头的: 例如: 0b11 则表示十进制的 3

8 进制是以 0o 开头的: 例如: 0o11 则表示十进制的 9

16 进制是以 0x 开头的: 例如: 0x11 则表示十进制的 17

但是在测试的时候又遇到了个问题，那就是输出来的被自动转化成了十进制：

>>> a=0b111100
>>> a
60
于是又去找了怎么输出二进制，得到了以下内容：

分别使用 bin，oct，hex 可输出数字的二进制，八进制，十六进制形式，例如：

>>> a=0b111100
>>> a=60
>>> bin(a)
'0b111100'
>>> oct(a)
'0o74'
>>> hex(a)
'0x3c'
疑问解决!
'''

'''
a = 0011 1100

b = 0000 1101

-----------------

a&b = 0000 1100

a|b = 0011 1101

a^b = 0011 0001

~a  = 1100 0011
'''

a = 60 # 60 = 0011 1100 
b = 13 # 13 = 0000 1101 
c = 0
c = a & b; # 12 = 0000 1100
print ("1 - c 的值为：", c)
c = a | b; # 61 = 0011 1101 
print ("2 - c 的值为：", c)
c = a ^ b; # 49 = 0011 0001
print ("3 - c 的值为：", c)
c = ~a; # -61 = 1100 0011
print ("4 - c 的值为：", c)
c = a << 2; # 240 = 1111 0000
print ("5 - c 的值为：", c)
c = a >> 2; # 15 = 0000 1111
print ("6 - c 的值为：", c)


'''
Python逻辑运算符
Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:

运算符	逻辑表达式	描述	实例
and	x and y	布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。	(a and b) 返回 20。
or	x or y	布尔"或" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。	(a or b) 返回 10。
not	not x	布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。	not(a and b) 返回 False
以上实例输出结果：
---
python 中的 and 从左到右计算表达式，若所有值均为真，则返回最后一个值，若存在假，返回第一个假值；
or 也是从左到右计算表达式，返回第一个为真的值；
其中数字 0 是假，其他都是真；
字符 "" 是假，其他都是真；
'''
a = 10
b = 20
if ( a and b ):
    print ("1 - 变量 a 和 b 都为 true")
else:
    print ("1 - 变量 a 和 b 有一个不为 true")
print("a and b =", a and b)
if ( a or b ):
    print ("2 - 变量 a 和 b 都为 true，或其中一个变量为 true")
else:
    print ("2 - 变量 a 和 b 都不为 true")
# 修改变量 a 的值
a = 0
if ( a and b ):
    print ("3 - 变量 a 和 b 都为 true")
else:
    print ("3 - 变量 a 和 b 有一个不为 true")
if ( a or b ):
    print ("4 - 变量 a 和 b 都为 true，或其中一个变量为 true")
else:
    print ("4 - 变量 a 和 b 都不为 true")
if not( a and b ):
    print ("5 - 变量 a 和 b 都为 false，或其中一个变量为 false")
else:
    print ("5 - 变量 a 和 b 都为 true")


'''
非常的精彩，指出了 python 与 c 语言概念上的一些差异，语言描述的可能未必准确，直接上例子：

>>> b = 5  
>>> a = 5  
>>> id(a)  
162334512  
>>> id(b)  
162334512  
>>> a is b  
True

可以看出， python 中，变量是以内容为基准而不是像 c 中以变量名为基准，所以只要你的数字内容是5，不管你起什么名字，这个变量的 ID 是相同的，同时也就说明了 python 中一个变量可以以多个名称访问。

这样的设计逻辑决定了 python 中数字类型的值是不可变的，因为如果如上例，a 和 b 都是 5，当你改变了 a 时，b 也会跟着变，这当然不是我们希望的。

因此，正确的自增操作应该 a = a + 1 或者 a += 1，当此 a 自增后，通过 id() 观察可知，id 值变化了，即 a 已经是新值的名称。
---
纠正一下楼上的一些观点

楼上的同学所说的在脚本式编程环境中没有问题。但是在交互式环境中，编译器会有一个小整数池的概念，会把（-5，256）间的数预先创建好，而当a和b超过这个范围的时候，两个变量就会指向不同的对象了，因此地址也会不一样，比如下例：

>>> a=1000
>>> b=1000
>>> id(a);id(b)
2236612366224
2236617350384
>>>
'''


'''
位运算，是自己平时最不熟悉的一块，相信很多人也是这样，但巧妙的运用位运算可以来解决很多题目，例如，剑指offer上面的一道：

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

# -*- coding:utf-8 -*-

class Solution:
    def NumberOf1(self, n):
        # write code here
        cnt = 0
        if n<0:
            n = n & 0xffffffff
        while n:
            cnt+=1
            n = (n-1) & n
        return cnt
通过按位与，巧妙的计算出二进制中"1"的个数。
'''







